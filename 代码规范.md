# 代码规范

## 1. 基本的格式化

### 1.1 缩进层级

* ```使用空格符进行缩进;```  

* ```四个空格符表示一个缩进层级;```

```javascript
function demo() {
    console.log('hello world)
}
```

### 1.2 语句结尾

* ```使用分号结尾```;

```javascript
// 正确的代码
var name = 'Nicholas'
function sayName() {
    alert(name)
}
```

* 错误实例：因ASI的分号插入规则复杂难记，会造成与原代码不同的执行结果；

```javascript
// 原始代码
function getData() {
    return
    {
        title: '',
        author: ''
    }
}
// 分析器会理解成
function getData () {
    return;
    {
        title: '',
        author: ''
    };
}
```

### 1.3 行的长度

* ```指定一行代码长度限定在80个字符；```

### 1.4 换行

* ```当一行长度超过最大字符数限制（80个字符），需手动将一行代码拆成两行，且下一行增加两个层级的缩进；```

```javascript
// 正确做法： 在运算符后换行，第二行追加两个缩进层级
callAFunction(document, element, window, 'some string value, true, 123,
        navigator);

// 不好的做法：第二行只有一个缩进
callAFunction(document, element, window, 'some string value, true, 123,
    navigator);

// 不好的做法：在运算符之前换行了
callAFunction(document, element, window, 'some string value, true, 123
        , navigator);
```

* ```注意：逗号也算一个运算符，应当作为前一行当结尾;```

* ```变量赋值时，第二行的位置应当与赋值运算符的位置保持对齐;```

```javascript
// 正确的做法
var result = something + anotherThing + yetAnotherThing + somethingElse +
             anotherSomethingElse;
// 确保代码的可读性，并能一眼看清折行的上下文
```

### 1.5 空行

* ```在方法之间加入空行```

* ```在方法中的局部变量和第一条语句之间加入空行```

* ```在多行或单行注释之前加入空行```

* ```在方法内的逻辑片段之间插入空行，提高可读性```

* ```在方法之间加入空行```

```javascript
// 好的写法
function anther () {

    for (let i = 0; i < wl.length; i++) {

        // 内部逻辑
        p = wl[i];

        if (s.hasOwnProperty(p)) {

            if (merge && type === 'object') {
                y.min(r[p], s[p]);
            } else {
                r[p] = s[p];
            }
        }
    }
}

/*
*多行注释
*/
function bather() {}
```

### 1.6 **命名**

* ```驼峰式大小写：小写字母开始，后续每个单词首字母都大写;```

```javascript
// 好的写法
var thisIsMyName;
var anotherVariable;
var aVeryLongariableName;
```

### 1.6.1 **变量和函数**

* ```变量名需总是遵守驼峰式大小写命名法，且命名前缀为【名词】，以名词做前缀可以让变量与函数区分开来；函数名前缀为【动词】```

```javascript
// 变量: 好的写法
var count = 10;
var myName = 'Nicholas';
var found = true;

// 不好的写法：变量看起来像函数
var getCount = 10;
var isFound = true;

// 函数： 好的写法
function getName () {
    return myName;
}

// 不好的写法： 函数看起来像变量
function theName() {
    return myName;
}
```

* ```对于函数和方法命名，第一个单词应该式动词；常见的一些使用动词的约定```
  
|动词|含义|
|:-: | :-:|
|   can     |函数返回一个布尔值|  
|   has     |函数返回一个布尔值|  
|   is     |函数返回一个布尔值|  
|   get     |函数返回一个非布尔值|  
|   set     |函数用来保存一个值|

### 1.6.2 **常量**

* ```常量使用大写字母和下划线来命名，下划线用以分割单词```

```javascript
var MAX_COUNT = 10;
var URL = 'http://www.nczonline.net/';
```

### 1.6.3 **构造函数**

* ```构造函数以'驼峰式大小写'命名,首字母为大写，名词```

```javascript
// 好的做法
function Person(name) {
    this.name = name
}

Person.prototype.sayName = function() {
    alert(this.name);
};

var me = new Person('Nicholas')
```

### 1.7 直接量

### 1.7.1 字符串

* ```字符串使用反引号括起来,并从头到尾保持一种风格```

```javascript
// 好的做法
var name = `Nicholas say`
```

### 1.7.2 数字

* ```在js中不可省略小数部分或者整数部分```

```javascript
// 整数
var count = 10;

// 小数
var price = 10.0;
var price = 10.00;

// 不推荐的小数写法：没有小数部分
var price = 10.;

//不推荐的小数写法： 没有整数部分
var price = .1;

//不推荐的写法： 八进制写法已经被弃用了
var num = 010;

// 十六进制写法
var num = 0xA2

// 科学计数法
var num = 1e23;
```

### 1.7.3 null

* ```null是个特殊值，切勿与undefind搞混;```
* ```null用来初始化一个变量，这个变量可能赋值为一个对象；```
* ```null用来和一个已经初始化的变量比较，这个变量有可能是也可能不是一个对象；```
* ```当函数的参数期望是对象时，用作参数传入；```
* ```当函数的返回值期望是对象时，用作返回值传出；```
* ```不要使用null来检测是否传入了某个参数；```
* ```不要用null来检测一个未初始化的变量```

```javascript
// 好的用法
var person = null;

// 好的用法
function getPerson() {
    if (condition) {
        return new Person('Nicholas')
    } else {
        return null;
    }
}

// 好的用法
var person = getPerson()
if (person !== null) {
    doSomething();
}

// 不好的写法： 用来和未初始化的变量比较
var person;
if (person !== null) {
    doSomething();
}

// 不好的写法： 检测是否传入了参数
function doSomething(arg1, agr2, arg3, arg4) {
    if (arg4 !== null) {
        doSomethingElse();
    }
}
```

* ```理解null最好的方式时将它当作对象的占位符；```

### 1.7.4 undefined

* ```未被初始化的变量都有一个初始值，即undefined;表示这个变量等待被赋值```

``` javascript
// 不好的写法
var person;
console.log(person === undefined); // true
```

* ```尽量避免在代码中使用undefined,这个值常常与返回'undefined'的typeof运算符混淆。```

```javascript
// foo未被声明
var person;
console.log(typeof person); // 'undefined'
console.log(typeof foo);    // 'undefined'
```

* ```通过禁止使用特殊值 undefined, 可以有效的保证只有一种情况下typeof才会返回'undefined'。如果使用了一个可能（或不可能）赋值为一个对象的变量时，则将其赋值为null。```

```javascript
// 好的做法
var person = null;
console.log(person === null);   // true
```

### 1.7.5 对象直接量

* ```对象直接量允许将所有的属性都括在一对花括号中；```

```javascript
// 好的写法
var book = {
    title: '',
    author: ''
}

// 不好的写法
var book = new Object();
book.title = '';
book.author = '';
```

### 1.7.6 数组直接量

* ```使用两个方括号将数组初始元素括起来，来替代Array的方式创建数组;```

```javascript
// 好的写法
var colors = ['red', 'green', 'blur'];
var numbers = [1,2,3,4];

// 不好的写法
var color = new Array('red', 'green', 'blur')
var numbers = new Array(1,2,3,4);
```

## 2. 注释

### 2.1 单行注释

* ```独占一行，用来解释下一行代码，且缩进层级和下一行代码保持一致;```
* ```在代码行的尾部的注释，代码结束到注释之间至少有一个缩进，且不超过单行最大字符数限制，如果超过，则放置在代码行的上方；```

```javascript
// 好的写法
if (condition) {

    // 代码执行逻辑
    allowed();
}

// 不好的写法：注释之前没有空行
if (condition) {
    // 代码逻辑
    allowed();
}

// 不好的写法： 错误的缩进
if (condition) {
// 代码执行逻辑
    allowed();
}

// 好的写法
var result = something + somethingElse; // 代码执行逻辑

// 不好的写法: 代码和注释之间没有间隔；
var result = something + somethingElse;// 代码执行逻辑
```

### 2.2 多行注释

* ```多行注释之前应当有一个空行，且缩进层级和其描述的代码保持一致；```

```javascript
// 好的写法
if (condition) {

    /*
    * 代码执行逻辑
    * 代码执行逻辑
    */
    allowed();
}
```

### 2.3 使用注释

* ```当代码不够清晰时添加注释，当代码很明了时不应当添加注释；```
* ```添加注释的一般原则是：在需要让代码变的更清晰时添加注释;```

```javascript
// 不好的写法

// 初始化count
var count = 10;

// 好的写法

//改变这个值可能会让它变成青蛙
var count = 10;
```

## 3. 语句和表达式

* ```在JavaScript中，不论块语句包含多行代码还是单行代码，都应该使用花括号```

```javascript
// 好的写法
if (condition) {
    doSomething();
}

// 不好的写法
if(condition)
    doSomething();

// 不好的写法
if(condition) doSomething();

// 不好的写法
if (condition) { doSomething(); }
```

### 3.1 花括号的对齐方式

* ```推荐使用的花括号对齐风格是：将左花括号放置在块语句的第一句代码的末尾。```

```javascript
// 好的做法
if (condition) {
    doSomething();
} else {
    doSomethingElse();
}
```

### 3.2 块语句间隔

* ```推荐风格：在括左圆括号之前和括右圆括号之后各添加一个空格```

```javascript
// 好的做法
if (condition) {
    doSomething();
}
```

### 3.3 switch语句

* ```无论何时都不应该省略default```

```javascript
// 好的做法
switch (condithing) {
    case 'first'
        // 代码
        break;
    default:
        // default中没有逻辑
}
```

## 4.变量、函数和运算符

### 4.1 变量声明

* ```必须将所有的变量声明放在函数顶部，而不是散落在各个角落```

```javascript
// 好的做法
function doSomething(items) {
    var i, len;
    var value = 10;
    var result = value + 10;

    for (i = 0; len = items.length; i < len; i++) {
        doSomething();
    }
}
```

* ```合并var语句，可以让代码更短更快：每个变量的初始化独占一行，赋值运算符应当对齐，没有初始值的变量，应当出现在var语句的尾部；```

```javascript
// 好的做法
function doSomething() {
    var value = 10,
        result = value + 10,
        i, len;
    for (i = 0; len = items.length; i < len; i++) {
        doSomething();
    }
}
```

### 4.2 函数声明

* ```必须先声明javascript函数再使用函数```

```javascript
// 好的写法
function doSomething() {
    alert('');
}

doSomething();

// 不好的写法
doSomething();

function doSomething() {
    alert('');
}
```

### 4.3 严格模式

* ```不要在全局作用域中使用"use strict"```

```javascript
// 不好的写法
"use strict"
function doSomething() {
    // 代码
}

// 好的写法
function doSomething() {
    "use strict"
    // 代码
}
```

### 4.4 相等

* ```所有情景下都应当使用全等===和不全等!==```

### 4.5 原始包装类型

* ```尽量禁止使用原始包装类型（String、Number、Boolean）来创建新对象```

```javascript
// 不好的做法
var name = new String('Nicholas');
var author = new Boolean(true);
var count = new Number(10);
```

## 5. 避免使用全局变量

* ```在浏览器中，window对象往往重载并等同于全局对象，，因此任何在全局作用域中声明点变量和函数都是window对象的属性；```

## 6.事件处理

* ```最佳实践：将应用逻辑从所有事件处理程序中抽离出来```

* ```规则 1: 隔离应用逻辑;```

```javascript
// 好的写法
var myApplication = {
    handleClick: function(event) {
        this.showPopup(event)
    },
    showPopup: function(event) {
        var popup = document.getElementById('popup');
        popup.style.left = event.clientX + 'px';
        popup.style.top = event.clientY + 'px';
        popup.className = 'reveal'
    }
};

addListener(element, 'click', function(event) {
    MyApplication.handleClick(event);
});
```

* ```规则 2: 不要分发事件对象, 最佳点办法是让事件处理程序使用event对象来处理事件；然后拿到所需要的数据传给应用逻辑```

```javascript
// 好的写法
var myApplication = {
    handleClick: function(event) {
        this.showPopup(event.clientX, event.clientY)
    },
    showPopup: function(x,y) {
        var popup = document.getElementById('popup');
        popup.style.left = x + 'px';
        popup.style.top = y + 'px';
        popup.className = 'reveal'
    }
};

addListener(element, 'click', function(event) {
    MyApplication.handleClick(event);
});

```

## 7. 避免空比较

```javascript
var Controller = {
    process: function(items) {
        if (items !== null) {   // 不好的写法
            items.sort();
            items.forEach(function() {
                // 执行逻辑
            })
        }
    }
}
```

## 7.1 检测原始值

* ```javascript有五种原始类型：字符串、数字、布尔值、null、undefined```
* ```判断五种原始类型，最好使用typeo运算符；```
* ```typeof运算符会返回一个表示值的类型的字符串```

```javascript
// 检测字符串
if (typeof name === 'string') {
    anotherName = name.substring(3);
}

// 检测数字
if (typeof count === 'number') {
    updateCount(count);
}

// 检测布尔值
if (typeof found === 'boolean' && found) {
    message('Found');
}

// 检测undefined
if (typeof MyApp === 'undefined') {
    MyApp = {}
}
```

* ```未定义到变量和值为undefined的变量，通过typeof都将返回'undefined'```
* ```原始值 null ,一般不用于检测语句，如果需要检测null,最好使用===或!==```

```javascript
typeof null 返回 'object'
编程时需要杜绝使用typeof来检测null的类型
```

### 7.2 检测引用值

* ```检测某个引用值的类型的最好方法是使用instanceof运算符```

```javascript
value instanceof constructor

// 检测日期
if (value instanceof Date) {
    console.log(value.getFullYear());
}

// 检测正则表达式
if (value instanceof RegExp) {
    if (value.test(anotherValue)) {
        console.log('Mathces');
    }
}

// 检测Error
if (value instanceof Error) {
    throw value;
}
```

* ```instanceof运算符可用于检测自定义的类型```

```javascript
function Person(name) {
    this.name = name;
}
var me = new Person('Nicholas');

console.log(me instanceof Object); // true
console.log(me instanceof Person); // true
```

### 7.2.1 检测函数

* ```javascript中的函数都是引用类型，同样存在Function构造函数，每个函数都是其实例;```

```javascript
function myFunc() {};

// 不好的写法
console.log(myFunc instanceof Function); // true
// 然而这个方法不能跨帧(frame)使用，因为每个帧都有各自的Function构造函数。但是可以使用typeof运算符检测函数

// 好的写法
console.log(typeof myFunc === 'function')
```

### 7.3 检测属性

* ```判断属性是否存在的最好办法是使用in运算符```

* ```in运算符仅仅会简单的判断属性是否存在，而不会去读取属性到值```

```javascript
var object = {
    count: 0,
    related:null
}

// 好的写法
if ('count' in object) {
    // 这里的代码会执行
}

// 不好的写法: 检测假值
if (object['count']) {
    // 这里的代码不会执行
}

// 好的写法
if ('related' in object) {
    // 这里的代码会执行
}

// 不好的写法： 检测是否为null
if (object['related'] !== null) {
    // 这里的代码不会执行
}
```

* ```检测实例对象的某个属性是否存在，则使用hasOwnProperty()方法，如果实例存在这个属性则返回true(如果这个属性只存在于原型里，则返回false)```

```javascript
// 对于所有非dom对象，这是最好的办法
if (object.hasOwnProperty('related')) {
    // 执行这里的代码
}

// 如果不确定是否为dom对象，
if ('hasOwnProperty' in object && object.hasOwnProperty('related')) {
    // 执行这里的代码
}
```

## 8 将配置数据从代码中分离出来

### 8.1 什么是配置数据

* ```配置数据是应用中写死的值```

```javascript
function validate(value) {
    if (!value) {
        alert('Invalid value')  // 可能会修改替换
        location.href = '/errors/invalid.php';  // 可能会修改替换
    }
}

function toggleSelected(element) {
    if (hasClass(element, 'selected')) {    // 'selected' 可能会修改替换
        removeClass(element, 'selected');   // 'selected' 可能会修改替换
    } else {
        addClass(element, 'selected')   // 'selected' 可能会修改替换

    }
}
```

* ```URL```
* ```需要展现给用户的字符串```
* ```重复的值```
* ```设置（比如每页的配置项)```
* ```任何可能发生变更的值```

### 8.2 抽离配置数据

* ```将配置数据从代码中抽离出来的第一步是将配置数据拿到外部，即将数据从JavaScript代码之中拿掉```

```javascript
var config = {
    MSG_INVALID_VALUE: 'Invalid value',
    URL_INVALID: 'errors/invalid.php',
    CSS_SELECTED: 'selected'
}
function validate(value) {
    if (!value) {
        alert(config.MSG_INVALID_VALUE);
        location.href = config.URL_INVALID;
    }
}
function toggleSelected(element) {
    if (hasClass(element, config.CSS_SELECTED)) {    // 'selected' 可能会修改替换
        removeClass(element, config.CSS_SELECTED);   // 'selected' 可能会修改替换
    } else {
        addClass(element, config.CSS_SELECTED)   // 'selected' 可能会修改替换

    }
}
```

### 8.3 保存配置数据

* ```配置数据最好放在单独的文件中，以便清晰的分隔数据和应用逻辑```
* ```将配置文件置于单独的JavaScript文件中,是一个不错的开始。一旦配置数据存放于单独的文件中，就可以管理这些数据```

## 9. 抛出自定义错误

### 9.1 在JavaScript中抛出错误

* ```使用throw操作符，将提供的一个对象作为错误抛出。```
* ```任何类型的对象都可以作为错误抛出，Error对象是最常用的```

> throw new Error('something bad happend')

```javascript
  // 不好的写法
  throw 'message';
```

* ```如果没有通过try-catch语句捕获，抛出任何值将引发一个错误```
* ```唯一不出差错的显示自动移动错误消息的方式就是使用一个Error对象```

### 9.2 抛出错误的好处

* ```抛出自己的错误可以使用确切的文本供浏览器显示```
* ```在错误消息中包含函数名称以及函数失败的原因```

